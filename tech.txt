4 oop alaptulajdonsága
--------------------------------------------------------------------------------------------
Encapsulation

Az enkapszuláció az a mechanizmus,mely folyamán az objekt tulajdonságait és metodusait elzárjuk az objektumban ezzel kifejezve hogy ezek össze tartoznak.
Ezen tul a fejlesztő az ö tetszése szerint tudja szabályozni a objekt adott fieldjeinek vagy metodusának elérhetőségi szintjét
--------------------------------------------------------------------------------------------
Inheritance

Az inheritance az a folyamat mely során egy osztály szert tesz egy másik objektum nem privát metodusaira és fieldjeire.
Az inheritance használatával, egyfajta hierachiát lehet kialakitani az osztályok közt, és elkerülhető hogy a fejlesztőnek ujra le kelljen irni ugyanazokat a metodusokat és fieldeket.
--------------------------------------------------------------------
Polimorfizmus

azt jelenti hogy "egy név, több forma"
Tehát egy kifejezés alatt több dolgot is érthetünk.
két féle képpen lehet elérni:
dynamic(override):
Mikor egy parent osztály referincát használunk, hogy egy child osztályra hivatkozzunk.
példa: Animal, cat osztály
Animal a = new Cat()
a.makeSound()


ugyan annak a visszatérési értékkel kell rendelkezzenek, az elérési szint nem lehet tiltoltabb a mint amit felülir,
staticis vagy final metodusokokat nem lehet override-olni, ha egy metodust nem lehet örökölni, akkor nem lehet overridolni

statikus(overload)
külömbözö metodusoknak ugyan az a neve, paraméterek száma és tipusa viszont eltérhet
----------------------------------------------------------------------------------------------------------------

Absztrakció
Az absztrakció olyan folyamat, mely folyamán az implementáció részleteit elrejtjük a felhasználó elöl, ezzel csökkentjük a komplexitást, és flexibilisebbé tesszük a kodokat.
Másszvakkal a felhasználó csak azt fogja tudni hogy az adott dolog mit csinál, nem pedig azt hogy hogyan
Leginkább két modszerünk van erre, az interfkészek és az absztrakt classok.

Pl:
Mikor egy metódusban egy listára számitunk mint paraméter, nem határozzuk meg hogy az most Arraylist vagy Linkedlist lesz csak simán egy olyan objektumot várunk, ami implementálja a List interfészt, és ezen keresztül adunk, és veszünk ki dolgokat a listából.


-----------------------------------------------------------------------------------------------

Association

Olyan kapcsolat melyben az objektumokat laza kapcsolatban vannak egymásban, másszóval tudnak egymás nélkül is létezni

Aggregation:

"has-a" relation

Hasonlit az association-hoz, csak itt van egy tulajdonos.

Compostion:
Hasonlit a aggregációhoz, viszont itt a tulajdonos nélkül, nem tud létezni a másik objektum

---------------------------------------------------------------------------------------

Single responsibility

Egy osztálynak csak egy oka lehet a változása, szóval egy osztálynak csak egy feladata lehet

A class should have one and only one reason to change, meaning that a class should have only one job.
 -------------------------------------------------------------------------------------------------
Open closed principle
Open for extension, closed for modification

Egy osztályhoz bármikor hozzá lehessen adni uj funkcionalitást, viszont ha már egyszer jól meg lett irva a source kód, azon nem szabad változtatni

-------------------------------------------------------------------------------------------

Liskov Substitution

Minden származtatótt(mászóval childclass) alkalmasnak kell lennie arra, hogy lecseréljük a parent class-ra.

Szóval egy childclass-nak ugy kell overridolnia a metodusokat, hogy azok ne törjék meg a funkcionalitást.

-------------------------------------------------------------------------------
Interface segregation

Egy felhasználót sosem szabad kényszeriteni, hogy interface implementáciükor olyan metodusokat implementáljon, amit nem fog használni.

példa

------------------------------------------
Dependency inversion
Az objektumoknak absztrakciókon kell függeniük, nem konkrétumokon.
Például Egy olyan objektumnak aminek valamilyen listára vagy szüksége, Ahelyett hogy konkrétan
Arraylist-et vagy Linkedlist-et adnánk meg függöségnek, szimplán annyit kell irnunk hogy hogy List interface-t implementálü dologra van szükségünk.
------------------------------------------------------
Absztrakt vs Interface:

Interface:

Az Interface leginkább olyan metodusok csoportja, amin keresztül kommunikálni lehet azokkal az objektekkel amik implementálják
az adott interface-t. Éltalába az interfacek segitenek elérni az absztrakcio-t, hiszen ha interfaceket használunk egy objektum-ra való kommunikációra akkor csak a viselkedést látjuk, nem az implementáció részleteit.

Amikor egy osztály implementál egy interface-t, akkor az interfaceben található összes metódust implmentálnia kell(kivéve ha az osztály absztrakt).
Egy interface-t nem lehet példányositani.

Abszrakt class:

Az absztrakt class olyan osztály amit nem lehet példányositani.
Általába mikor az osztályok hierarchiáját tervezzük, akkor az absztrakt klassz egyfajta al


-----------------------------------------------------
Exception:
Amikor metódusban valami hiba történik, akkor egy metodus létrehöz hogy Exception objektumot. Ez az objektum külömbözö információkat tartalmaz a hibákról. Miután létrehózta, a program elkezdi megkeresni azt a kodot,(a callstackban "lefelé haladva"), ami ennek a expcetionnek a kezelésére irodott, ezt hivjuk exception handlernek. Ha sehol se talált az exception fajtájának megfelelő exception handlert, akkor
a program leál

futtat != fordul

Checked:

Generikus:tipusbiztonság
boxing unboxing







